from PIL import Image
import numpy as np
import pickle as pkl

def RGBtoYCbCr(foto):
    pix = foto.load()
    x, y = foto.size

    image = Image.new("YCbCr", (x, y))

    for i in range (x):
        for j in range (y):
            R,G,B = pix[i,j]

            Y = round(0.299*(R)+0.587*(G)+0.114*(B))
            Cb = round(-0.1687*(R) -0.3313*(G) + 0.5  *(B) + 128)
            Cr = round(0.5  *(R) - 0.4187*(G) - 0.0813*(B) + 128)

            Y = min(max(Y, 0), 255)
            Cb = min(max(Cb, 0), 255)
            Cr = min(max(Cr, 0), 255)

            image.putpixel((i, j), (Y, Cb, Cr))

    return image

def ycbcr_to_rgb(ycbcr):
    x, y = ycbcr.size
    image = Image.new("RGB", (x, y))
    pix = ycbcr.load()


    for i in range (x):
        for j in range (y):
            Y, Cb, Cr = pix[i,j]

            R = round(Y + 1.402 * (Cr-128.))
            G = round(Y - 0.344136 * (Cb-128.) - 0.714136 * (Cr-128.))
            B = round(Y + 1.772 * (Cb-128.))

            image.putpixel((i, j), (R, G, B))

    return image

def downsemp(foto, factor=2):
    pix = foto.load()
    x, y = foto.size

    image = Image.new("YCbCr", (x, y))

    for i in range(0, x, factor):
        for j in range(0, y, factor):
            Cb_color = pix[i, j][1]
            Cr_color = pix[i, j][2]

            for fi in range(factor):
                for fj in range(factor):
                    if i + fi < x and j + fj < y:
                        image.putpixel((i + fi, j + fj), (pix[i + fi, j + fj][0], Cb_color, Cr_color))

    return image

def splitImg(image, n=8):
    global num_x, num_y
    x, y = image.size

    num_x = (x + n - 1) // n
    num_y = (y + n - 1) // n

    blocksi = []
    blocksj = []
    blocksk = []
    pix = image.load()

    for i in range(num_x):
        for j in range(num_y):
            start_row = i * n
            start_col = j * n
            end_row = min(start_row + n, y)
            end_col = min(start_col + n, x)

            block_height = end_row - start_row
            block_width = end_col - start_col

            if block_height > 0 and block_width > 0:
                blocki = np.zeros((block_height, block_width, 1), dtype=np.uint8)
                blockj = np.zeros((block_height, block_width, 1), dtype=np.uint8)
                blockk = np.zeros((block_height, block_width, 1), dtype=np.uint8)

                for bi in range(block_height):
                    for bj in range(block_width):
                        blocki[bi, bj], blockj[bi, bj],blockk[bi, bj] = pix[bj + start_col, bi + start_row]

                blocksi.append(blocki)
                blocksj.append(blockj)
                blocksk.append(blockk)
    return blocksi, blocksj, blocksk

##def splitImg(image, n=8):
##    global num_x, num_y
##    x, y = image.size
##
##    num_x = (x + n - 1) // n
##    num_y = (y + n - 1) // n
##
##    blocksi = []
##    pix = image.load()
##
##    for i in range(num_x):
##        for j in range(num_y):
##            start_row = i * n
##            start_col = j * n
##            end_row = min(start_row + n, y)
##            end_col = min(start_col + n, x)
##
##            block_height = end_row - start_row
##            block_width = end_col - start_col
##
##            if block_height > 0 and block_width > 0:
##                blocki = np.zeros((block_height, block_width, 1), dtype=np.uint8)
##
##                for bi in range(block_height):
##                    for bj in range(block_width):
##                        blocki[bi, bj] = pix[bj + start_col, bi + start_row]
##
##                blocksi.append(blocki)
##    return blocksi

def DCTII(matrixi):
    shape = matrixi.shape
    dct_resultsi = []

    for i in range(shape[0]):
        blocki = matrixi[i]

        N, M = blocki.shape[:2]
        dct_matrixi = np.zeros((N, M))

        for u in range(N):
            for v in range(M):
                sum_val = 0
                for x in range(N):
                    for y in range(M):
                        sum_val += blocki[x, y] * np.cos(((2 * x + 1) * u * np.pi) / (2 * N)) * np.cos(((2 * y + 1) * v * np.pi) / (2 * M))

                Cu = 1 / np.sqrt(N) if u == 0 else np.sqrt(2 / N)
                Cv = 1 / np.sqrt(M) if v == 0 else np.sqrt(2 / M)

                dct_matrixi[u, v] = Cu * Cv * sum_val

        dct_resultsi.append(dct_matrixi)

    return np.array(dct_resultsi)

def IDCTII(dct_matrix):
    shape = dct_matrix.shape
    idct_results = []

    for i in range(shape[0]):
        block = dct_matrix[i]

        N, M = block.shape[:2]
        idct_matrix = np.zeros((N, M))

        for x in range(N):
            for y in range(M):
                sum_val = 0
                for u in range(N):
                    for v in range(M):
                        Cu = 1 / np.sqrt(N) if u == 0 else np.sqrt(2 / N)
                        Cv = 1 / np.sqrt(M) if v == 0 else np.sqrt(2 / M)
                        sum_val += Cu * Cv * block[u, v] * np.cos(((2 * x + 1) * u * np.pi) / (2 * N)) * np.cos(((2 * y + 1) * v * np.pi) / (2 * M))

                idct_matrix[x, y] = sum_val

        idct_results.append(idct_matrix)

    return np.array(idct_results)

def QuantTransf(dct_results, quant_matrix):
    N, M = quant_matrix.shape
    quantized_results = []
    for dct_block in dct_results:
        quantized_block = np.round(dct_block / quant_matrix)
        quantized_results.append(quantized_block)

    return np.array(quantized_results)

def iQuantTransf(dct_results, quant_matrix):
    N, M = quant_matrix.shape
    quantized_results = []
    for dct_block in dct_results:
        quantized_block = np.round(dct_block * quant_matrix)
        quantized_results.append(quantized_block)

    return np.array(quantized_results)

def zigzag(matrix):
    result = []

    n = len(matrix[0])
    m = len(matrix[0][0])

    for k in matrix:
        for d in range(n + m - 1):
            if d % 2 == 0:
                for i in range(min(d, m - 1), max(-1, d - n), -1):
                    j = d - i
                    if 0 <= j < n and 0 <= i < m:
                        value = k[j][i]
                        result.append(int(value))
            else:
                for i in range(max(0, d - n + 1), min(d + 1, m)):
                    j = d - i
                    if 0 <= j < n and 0 <= i < m:
                        value = k[j][i]
                        result.append(int(value))

    return result

def izigzag(arr):
    n, m = 8,8
    matrix = np.zeros((n, m), dtype=int)

    index = 0
    for d in range(n + m - 1):
        if d % 2 == 0:
            for i in range(min(d, m - 1), max(-1, d - n), -1):
                j = d - i
                if 0 <= j < n and 0 <= i < m:
                    matrix[j][i] = arr[index]
                    index += 1
        else:
            for i in range(max(0, d - n + 1), min(d + 1, m)):
                j = d - i
                if 0 <= j < n and 0 <= i < m:
                    matrix[j][i] = arr[index]
                    index += 1

    return matrix

def DCY(dcY):
    huf = []
    with open('hufTableDClum.txt', 'r') as file:
        for line in file:
            line = line.strip()
            if line:
                huf.append(list(map(int, line.split())))

    result = ''

    dcY_new = []
    dcY_new.append(dcY[0])
    prev = dcY[0]
    for cur in dcY[1:]:
        dif = cur-prev
        dcY_new.append(dif)
        prev = cur

    for j in dcY_new:
        for i in huf:
            categ, lenght, codeh = i
            if str(codeh) == '10' or str(codeh)=='11':
                codeh = f"{codeh:03}"
            if str(codeh) == '0':
                codeh = f"{codeh:02}"
            if j<0:
                if len(bin(j)[3:])==categ:
                    result+=(str(codeh)+bin(j)[3:])
            else:
                if len(bin(j)[2:])==categ:
                    result+=(str(codeh)+bin(j)[2:])
    return result

def DCCbCr(dcCbCr):
    huf = []
    with open('hufTableDCcol.txt', 'r') as file:
        for line in file:
            line = line.strip()
            if line:
                huf.append(list(map(int, line.split())))

    result = ''

    dcCbCr_new = []
    dcCbCr_new.append(dcCbCr[0])
    prev = dcCbCr[0]
    for cur in dcCbCr[1:]:
        dif = cur-prev
        dcCbCr_new.append(dif)
        prev = cur

    for j in dcCbCr:
        for i in huf:
            categ, lenght, codeh = i
            if str(codeh) == '00':
                codeh = f"{codeh:03}"
            if str(codeh) == '1':
                codeh = f"{codeh:02}"
            if j<0:
                if len(bin(j)[3:])==categ:
                    result+=(str(codeh)+bin(j)[3:])
            else:
                if len(bin(j)[2:])==categ:
                    result+=(str(codeh)+bin(j)[2:])
    return result

def ACY(data):
    huf = []
    with open('hufTableAClum.txt', 'r') as file:
        for line in file:
            line = line.strip()
            if line:
                huf.append(list(map(int, line.split())))

    Ac_new = []
    nulCNT = 0
    for i in data:
        if i==0:
            if nulCNT==15:
                Ac_new.append((15,0))
                nulCNT=-1
            nulCNT+=1
        else:
            Ac_new.append((nulCNT, i))
            nulCNT=0
    if nulCNT != 0:
        Ac_new.append((nulCNT-1, 0))

    result = ''

    for i in Ac_new:
        nulNum, ch = i
        for j in huf:
            nulNumH, chH, lenght, codeh = j
            if str(codeh) == '0' or str(codeh)=='1':
                codeh = f"{codeh:02}"
            if ch<0:
                if nulNum==nulNumH and len(bin(ch)[3:]) == chH:
                    result+=(str(codeh)+bin(ch)[3:])
            else:
                if nulNum==nulNumH and len(bin(ch)[2:]) == chH:
                    result+=(str(codeh)+bin(ch)[2:])


    return result

def ACcbcr(data):
    huf = []
    with open('hufTableACcol.txt', 'r') as file:
        for line in file:
            line = line.strip()
            if line:
                huf.append(list(map(int, line.split())))

    Ac_new = []
    nulCNT = 0
    for i in data:
        if i==0:
            if nulCNT==15:
                Ac_new.append((15,0))
                nulCNT=-1
            nulCNT+=1
        else:
            Ac_new.append((nulCNT, i))
            nulCNT=0
    if nulCNT != 0:
        Ac_new.append((nulCNT-1, 0))

    result = ''

    for i in Ac_new:
        nulNum, ch = i
        for j in huf:
            nulNumH, chH, lenght, codeh = j
            if str(codeh) == '0' or str(codeh)=='1':
                codeh = f"{codeh:02}"
            if ch<0:
                if nulNum==nulNumH and len(bin(ch)[3:]) == chH:
                    result+=(str(codeh)+bin(ch)[3:])
            else:
                if nulNum==nulNumH and len(bin(ch)[2:]) == chH:
                    result+=(str(codeh)+bin(ch)[2:])

    return result

def RLE(s: bytes) -> bytes:
    if not s:
        return b''

    compressed = bytearray()
    counter = 1
    Ncounter = 0
    prev_symb = s[0]
    flag = False
    Nep = []

    for symb in s[1:]:
        if prev_symb == symb:
            if flag == True:
                while Ncounter > 127:
                    compressed.append(127 | 0x80)
                    for i in Nep[:127]:
                        compressed.append(i)
                    Ncounter -= 127
                    Nep = Nep[127:]
                compressed.append(Ncounter | 0x80)
                for i in Nep:
                    compressed.append(i)
                flag = False
                Nep = []
                Ncounter = 0
            counter += 1
        else:
            if counter > 1:
                while counter>127:
                    compressed.append(127 & 0x7F)
                    compressed.append(prev_symb)
                    counter -= 127
                compressed.append(counter & 0x7F)
                compressed.append(prev_symb)
                counter = 1
            else:
                if flag == False:
                    flag = True
                Ncounter += 1
                Nep.append(prev_symb)
            prev_symb = symb


    if counter > 1:
        compressed.append(counter & 0x7F)
        compressed.append(prev_symb)
    else:
        compressed.append((1 << 7) | 1)
        compressed.append(prev_symb)

    return bytes(compressed)

def ToBytes(binary_string):
    number = int(binary_string, 2)
    byte_length = (number.bit_length() + 7) // 8
    byte_order = 'big'
    byte_array = number.to_bytes(byte_length, byte_order)
    return byte_array

def BBS(byte_array):
    bs = ''.join(format(byte, '08b') for byte in byte_array)
    return bs.lstrip('0')

def iRLE(compressed: bytes) -> bytes:
    s = bytearray()
    i = 0
    N = len(compressed)

    while i < N:
        count = compressed[i]
        if count & 0x80:
            count = count & 0x7F
            while count > 0:
                s.append(compressed[i + 1])
                count-=1
                i+=1
            i += 1
        else:
            symb = compressed[i + 1]
            s.extend([symb] * count)
            i += 2

    return bytes(s)

def iDCY(dcY):
    huf = []
    with open('hufTableDClum.txt', 'r') as file:
        for line in file:
            line = line.strip()
            if line:
                huf.append(list(map(int, line.split())))

    res = []
    i = 0

    while i < len(dcY):
        found = False
        for j in huf:
            categ, lenght, codeh = j
            if str(codeh) == '10' or str(codeh)=='11':
                codeh = f"{codeh:03}"
            if str(codeh) == '0':
                codeh = f"{codeh:02}"
            if str(dcY[i:i + len(str(codeh))]) == str(codeh):
                res.append(int(dcY[i + len(str(codeh)):i + len(str(codeh)) + categ], 2))
                i += len(str(codeh))
                i += categ
                found = True
                break

        if not found:
            i += 1

    result = []
    result.append(res[0])
    prev = res[0]
    for cur in res[1:]:
        summ = cur + prev
        result.append(summ)
        prev = summ

    return result

def iDCCBCR(dcCbCr):
    huf = []
    with open('hufTableDCcol.txt', 'r') as file:
        for line in file:
            line = line.strip()
            if line:
                huf.append(list(map(int, line.split())))

    res = []
    i = 0

    while i < len(dcCbCr):
        found = False
        for j in huf:
            categ, lenght, codeh = j
            if str(codeh) == '00':
                codeh = f"{codeh:03}"
            if str(codeh) == '0' or str(codeh)=='1':
                codeh = f"{codeh:02}"
            if str(dcCbCr[i:i + len(str(codeh))]) == str(codeh):
                res.append(int(dcCbCr[i + len(str(codeh)):i + len(str(codeh)) + categ], 2))
                i += len(str(codeh))
                i += categ
                found = True
                break

        if not found:
            i += 1

    result = []
    result.append(res[0])
    prev = res[0]
    for cur in res[1:]:
        summ = cur + prev
        result.append(summ)
        prev = summ

    return result

def iACY(data):
    huf = []
    with open('hufTableAClum.txt', 'r') as file:
        for line in file:
            line = line.strip()
            if line:
                huf.append(list(map(int, line.split())))

    res = []
    i = 0

    while i < len(data):
        found = False
        for j in huf:
            nulh, chh, lenght, codeh = j
            if str(codeh) == '0' or str(codeh)=='1':
                codeh = f"{codeh:02}"
            if str(data[i:i + len(str(codeh))]) == str(codeh):
                res.append((nulh, int(data[i + len(str(codeh)):i + len(str(codeh)) + chh], 2)))
                i += len(str(codeh))
                i += chh
                found = True
                break

        if not found:
            res.append(data[i])
            i += 1

    result = []

    for i in res:
        nul, ch = i
        j=0
        while j<nul:
            result.append(0)
            j+=1
        result.append(ch)

    return result

def iACCBCR(data):
    huf = []
    with open('hufTableACcol.txt', 'r') as file:
        for line in file:
            line = line.strip()
            if line:
                huf.append(list(map(int, line.split())))

    res = []
    i = 0

    while i < len(data):
        found = False
        for j in huf:
            nulh, chh, lenght, codeh = j
            if str(codeh) == '0' or str(codeh)=='1':
                codeh = f"{codeh:02}"
            if str(data[i:i + len(str(codeh))]) == str(codeh):
                res.append((nulh, int(data[i + len(str(codeh)):i + len(str(codeh)) + chh], 2)))
                i += len(str(codeh))
                i += chh
                found = True
                break

        if not found:
            res.append(data[i])
            i += 1

    result = []

    for i in res:
        nul, ch = i
        j=0
        while j<nul:
            result.append(0)
            j+=1
        result.append(ch)

    return result

def mergeImg(blocks_Y, blocks_Cb, blocks_Cr):
    num_blocks_height, num_blocks_width, block_height, block_width = 8,8,8,8

    height = num_blocks_height * block_height
    width = num_blocks_width * block_width

    reconstructed_image = np.zeros((height, width, 3), dtype=float)

    for i in range(num_blocks_height):
        for j in range(num_blocks_width):
            start_y = i * block_height
            start_x = j * block_width

            reconstructed_image[start_y:start_y + block_height, start_x:start_x + block_width, 0] = blocks_Y[i, j]
            reconstructed_image[start_y:start_y + block_height, start_x:start_x + block_width, 1] = blocks_Cb[i, j]
            reconstructed_image[start_y:start_y + block_height, start_x:start_x + block_width, 2] = blocks_Cr[i, j]

    reconstructed_image = np.clip(reconstructed_image, 0, 255)

    reconstructed_image = reconstructed_image.astype(np.uint8)
    return Image.fromarray(reconstructed_image)

def main():
    img = Image.open(r"C:\Users\ASUS\Desktop\aisd22\lenna.raw")

    c = 50

    qY = np.array([[16, 11, 10, 16, 24, 40, 51, 61],
                                     [12, 12, 14, 19, 26, 58, 60, 55],
                                     [14, 13, 16, 24, 40, 57, 69, 56],
                                     [14, 17, 22, 29, 51, 87, 80, 62],
                                     [18, 22, 37, 56, 68, 109, 103, 77],
                                     [24, 35, 55, 64, 81, 104, 113, 92],
                                     [49, 64, 78, 87, 103, 121, 120, 101],
                                     [72, 92, 95, 98, 112, 100, 103, 99]])/c

    qCbCr = np.array([[17, 18, 24, 47, 99, 99, 99, 99],
                                     [18, 21, 26, 66, 99, 99, 99, 99],
                                     [24, 26, 56, 99, 99, 99, 99, 99],
                                     [47, 66, 99, 99, 99, 99, 99, 99],
                                     [99, 99, 99, 99, 99, 99, 99, 99],
                                     [99, 99, 99, 99, 99, 99, 99, 99],
                                     [99, 99, 99, 99, 99, 99, 99, 99],
                                     [99, 99, 99, 99, 99, 99, 99, 99]])/c

    img = RGBtoYCbCr(img)
    img = downsemp(img)
    blockY, blockCb, blockCr = splitImg(img)

    resultDCY = []
    resultDCCB = []
    resultDCCR = []

    resultACY = []
    resultACCB = []
    resultACCR = []

    for i in range(len(blockY)):

        dcY = []
        dcCb = []
        dcCr = []

        acY = []
        acCb = []
        acCr = []

        blockiY = DCTII(blockY[i])
        blockiCb = DCTII(blockCb[i])
        blockiCr = DCTII(blockCr[i])

        blockiY = QuantTransf(blockiY, qY)
        blockiCb = QuantTransf(blockiCb, qCbCr)
        blockiCr = QuantTransf(blockiY, qCbCr)

        zagY = zigzag(blockiY)
        zagCb = zigzag(blockiCb)
        zagCr = zigzag(blockiCr)



        for j in range (len(zagY)):
            if j%64 == 0:
                dcY.append(zagY[j])
            else:
                acY.append(zagY[j])

        for j in range (len(zagCb)):
            if j%64 == 0:
                dcCb.append(zagCb[j])
            else:
                acCb.append(zagCb[j])

        for j in range (len(zagCr)):
            if j%64 == 0:
                dcCr.append(zagCr[j])
            else:
                acCr.append(zagCr[j])

        resdcY = DCY(dcY)
        resdcCb = DCCbCr(dcCb)
        resdcCr = DCCbCr(dcCr)

        resacY = ACY(acY)
        resacCb = ACcbcr(acCb)
        resacCr = ACcbcr(acCr)

        if (resdcY):
            resdcY = ToBytes(resdcY)
        resultDCY.append(resdcY)
####        print(resdcY)
##        else:
##            result+=b'*'
##
        if resacY:
            resacY = ToBytes(resacY)
##            resacY = RLE(resacY)
        resultACY.append(resacY)
##        else:
####        print(resacY)
##            result+=b'*'

        if resdcCb:
            resdcCb = ToBytes(resdcCb)
        resultDCCB.append(resdcCb)
##        else:
##
####        print(resdcCb)
##            result+=b'*'
##
        if resacCb:
            resacCb = ToBytes(resacCb)
##            resacCb = RLE(resacCb)
        resultACCB.append(resacCb)
##        else:
##            result+=b'*'
####        print(resacCb)
##
        if resdcCr:
            resdcCr = ToBytes(resdcCr)
        resultDCCR.append(resdcCr)
##        else:
##            result+=b'*'
####        print(resdcCr)
##
        if resacCr:
            resacCr = ToBytes(resacCr)
##            resacCr = RLE(resacCr)
        resultACCR.append(resacCr)

    with open('output_file.txt', 'wb') as f:
        pkl.dump((resultDCY,resultDCCB,resultDCCR),f)
        pkl.dump((resultACY,resultACCB,resultACCR),f)

    ArY = []
    ArCb = []
    ArCr = []

    with open('output_file.txt', 'rb') as f:
        resdcY, resdcCb, resdcCr = pkl.load(f)
        resacY,resacCb,resacCr = pkl.load(f)
        for i in range(len(resdcY)):

            zigzY = []
            zigzCb = []
            zigzCr = []

            rDcY = BBS(resdcY[i])
            rDcCb = BBS(resdcCb[i])
            rDcCr = BBS(resdcCr[i])

##            rAcY = iRLE(resacY[i])
##            rAcCb = iRLE(resacCb[i])
##            rAcCr = iRLE(resacCr[i])

            rAcY = BBS(resacY[i])
            rAcCb = BBS(resacCb[i])
            rAcCr = BBS(resacCr[i])

            rDcY = iDCY(str(rDcY))
            rDcCb = iDCCBCR(str(rDcCb))
            rDcCr = iDCCBCR(str(rDcCr))

            rAcY = iACY(str(rAcY))
            rAcCb = iACCBCR(str(rAcCb))
            rAcCr = iACCBCR(str(rAcCr))

            k=0
            z=0
            for j in range (512):
                if z>len(rAcY):
                    break
                if j%64==0:
                    zigzY.append(rDcY[k])
                    k+=1
                else:
                    zigzY.append(rAcY[z])
                    z+=1

            k=0
            z=0
            for j in range (512):
                if z>len(rAcCb):
                    break
                if j%64==0:
                    zigzCb.append(rDcCb[k])
                    k+=1
                else:
                    zigzCb.append(rAcCb[z])
                    z+=1

            k=0
            z=0
            for j in range (512):
                if z>len(rAcCr):
                    break
                if j%64==0:
                    zigzCr.append(rDcCr[k])
                    k+=1
                else:
                    zigzCr.append(rAcCr[z])
                    z+=1

            zagresY = []
            for j in range (8):
                aftZagY = izigzag(zigzY[j*64:(j+1)*64])
                zagresY.append(aftZagY)

            zagresCb = []
            for j in range (8):
                aftZagCb = izigzag(zigzCb[j*64:(j+1)*64])
                zagresCb.append(aftZagCb)

            zagresCr = []
            for j in range (8):
                aftZagCr = izigzag(zigzCr[j*64:(j+1)*64])
                zagresCr.append(aftZagCr)

            QY = iQuantTransf(zagresY, qY)
            QCb = iQuantTransf(zagresCb, qCbCr)
            QCr = iQuantTransf(zagresCr, qCbCr)

            QY = IDCTII(QY)
            QCb = IDCTII(QCb)
            QCr = IDCTII(QCr)

            ArY.append(QY)
            ArCb.append(QCb)
            ArCr.append(QCr)

        resimg = mergeImg(ArY, ArCb, ArCr)
        resimg = ycbcr_to_rgb(resimg)

        resimg.show()





if __name__ == '__main__':
    main()
